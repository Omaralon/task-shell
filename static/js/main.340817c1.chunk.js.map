{"version":3,"sources":["utils/lexer.js","utils/parser.js","App.utils.js","data/tasklist-commands.js","data/task-commands.js","components/input-shell/input-shell.jsx","components/select-tasklist-button/select-tasklist-button.jsx","components/select-tasklists/select-tasklists.jsx","components/tasklist-header/tasklist-header.jsx","components/tasklist-description/tasklist-description.jsx","components/tasklist-task-row/tasklist-task-row.jsx","components/tasklist-tasks/tasklist-tasks.jsx","components/tasklist-table/tasklist-table.jsx","components/save-image-button/save-image-button.jsx","App.js","utils/storage-backup.js","utils/index.js","index.js"],"names":["isKeyword","c","test","isWhiteSpace","isQuote","isDigit","tokenTypes","StmtKeyword","ElmtKeyword","AttrKeyword","TitleText","DescriptionText","DateFormat","Number","Lexer","input","this","tokens","i","lex","type","value","push","keyword","next","length","toLowerCase","addToken","Error","title","description","dateOrNumber","str","isValidNumber","parseKeyword","parseTitleText","parseDescriptionText","parseNumberOrDate","require","TaskListParser","taskListsObj","taskListsArray","tokenIdx","modTaskListsArray","JSON","parse","stringify","startParsing","stmtValue","resolve","elmtValue","createTaskList","createTask","modifyTaskList","modifyTask","removeTaskList","removeTask","taskListId","taskId","resolveTaskListId","tasks","tokenType","isAnyTokenLeft","getCurrentToken","attrValue","actualAttrValue","date","time","resolveTaskIdOfTaskList","splice","isCurrentTokenAttrValue","addTaskList","parseInt","addTask","undefined","changeTaskList","changeTask","currentToken","isEraseDescription","isEraseDate","isEraseTaskList","eraseTaskList","isEraseTask","isEraseTime","eraseTask","generateTableImage","taskLists","selTaskList","a","html2canvas","document","querySelector","canvas","window","navigator","msSaveBlob","msToBlob","createElement","body","appendChild","href","toDataURL","download","click","removeChild","TasklistCommands","TaskCommands","InputShell","commandInput","handleCommandInput","handleKeyDown","className","onChange","onKeyDown","placeholder","SelectTasklistButton","btnContainerClass","instructionBtn","taskListTitle","isSelected","changeSelection","onClick","SelectTasklists","instructionsList","selectedTaskListId","map","taskList","id","key","TaskListHeader","TaskListDescription","TaskListTaskRow","TaskListTasks","taskProps","TaskListTable","props","PureComponent","SaveImageButton","children","App","tasklistsBackup","state","localStorage","setItem","event","target","setState","substring","handleChangeTasklist","selectedIndex","currentTasklist","selInstrList","backupTaskLists","handleChangeInstructionList","instructionsArr","runExecutionCommand","prevState","inputCommandsArr","taskListsLength","prevTaskListsLength","prevSelTaskList","lexer","getModTaskListsArray","error","message","runProvidedCommand","newSelTaskList","maxCachedInputs","shift","commandError","cachedInputsIdx","keyCode","commandsArrLen","isLoading","taskListsBackup","getItem","commandsHistoryBackup","Component","React","memo","ReactDOM","render","getElementById"],"mappings":"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,CACvB5E,MAAO,oBACPC,YACE,oGACFoC,KAAM,aACNN,MAAO,CAEL,CACE/B,MAAO,2BACPC,YAAa,GACbqC,KAAM,GAER,CACEtC,MAAO,yBACPC,YAAa,mCACbqC,KAAM,GAER,CACEtC,MAAO,mCACPC,YACE,+EACFqC,KAAM,GAER,CACEtC,MAAO,4BACPC,YAAa,mDACbqC,KAAM,GAER,CACEtC,MAAO,iDACPC,YACE,+FACFqC,KAAM,GAGR,CACEtC,MAAO,2BACPC,YAAa,GACbqC,KAAM,GAER,CACEtC,MAAO,wBACPC,YAAa,wDACbqC,KAAM,GAER,CACEtC,MAAO,8BACPC,YACE,yEACFqC,KAAM,GAER,CACEtC,MAAO,uBACPC,YAAa,8CACbqC,KAAM,GAER,CACEtC,MAAO,8DACPC,YACE,oHACFqC,KAAM,GAGR,CACEtC,MAAO,4BACPC,YAAa,GACbqC,KAAM,GAER,CACEtC,MAAO,kCACPC,YAAa,8BACbqC,KAAM,GAER,CACEtC,MAAO,8BACPC,YAAa,0CACbqC,KAAM,GAER,CACEtC,MAAO,uBACPC,YAAa,mCACbqC,KAAM,GAER,CACEtC,MAAO,uCACPC,YAAa,+CACbqC,KAAM,KCSGuC,EA/FM,CACnB7E,MAAO,gBACPC,YACE,gGACFoC,KAAM,aACNN,MAAO,CAEL,CACE/B,MAAO,uBACPC,YAAa,GACbqC,KAAM,GAER,CACEtC,MAAO,qBACPC,YAAa,4CACbqC,KAAM,GAER,CACEtC,MAAO,+BACPC,YACE,gFACFqC,KAAM,GAER,CACEtC,MAAO,6CACPC,YACE,wEACFqC,KAAM,GAER,CACEtC,MAAO,uDACPC,YACE,4GACFqC,KAAM,GAGR,CACEtC,MAAO,4BACPC,YAAa,GACbqC,KAAM,GAER,CACEtC,MAAO,oBACPC,YACE,8DACFqC,KAAM,GAER,CACEtC,MAAO,0BACPC,YACE,+EACFqC,KAAM,GAER,CACEtC,MAAO,6BACPC,YACE,uEACFqC,KAAM,GAER,CACEtC,MACE,oEACFC,YACE,sIACFqC,KAAM,GAGR,CACEtC,MAAO,wBACPC,YAAa,GACbqC,KAAM,GA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","file":"static/js/main.340817c1.chunk.js","sourcesContent":["const isKeyword = c => /[a-z]/i.test(c);\nconst isWhiteSpace = c => c === ' ';\nconst isLBracket = c => c === '[';\nconst isQuote = c => c === '\"';\nconst isDigit = c => /\\d/.test(c);\nconst isValidDate = str =>\n  /^([0-2][0-9]|(3)[0-1])(\\/)(((0)[0-9])|((1)[0-2]))(\\/)\\d{4}$/i.test(str);\nconst isValidNumber = str => /^\\d+$/.test(str);\n\n// This is an object of constants of token types, for us to not make some silly typos when\n// pushing new tokens or when making comparisons\nexport const tokenTypes = {\n  StmtKeyword: 'StmtKeyword', //  options: ['create', 'modify', 'remove']\n  ElmtKeyword: 'ElmtKeyword', //  options: [\"tasklist\", \"task\"]\n  AttrKeyword: 'AttrKeyword', //  options: [\"description\", \"date\", \"time\", \"title\", \"from\"]\n  TitleText: 'TitleText',\n  DescriptionText: 'DescriptionText',\n  DateFormat: 'DateFormat',\n  Number: 'Number'\n};\n\nclass Lexer {\n  constructor(input) {\n    this.input = input;\n    this.tokens = [];\n    this.i = 0; // input index count\n    this.c = ''; // current character from input\n\n    this.lex();\n  }\n\n  next() {\n    this.i++;\n    return (this.c = this.input[this.i]);\n  }\n\n  addToken(type, value) {\n    this.tokens.push({ type, value });\n  }\n\n  parseKeyword() {\n    let keyword = this.c; // Setting the initial character of the keyword\n\n    while (isKeyword(this.next()) && this.i < this.input.length)\n      keyword += this.c;\n\n    keyword = keyword.toLowerCase();\n\n    switch (keyword) {\n      case 'create':\n      case 'modify':\n      case 'remove':\n        this.addToken(tokenTypes['StmtKeyword'], keyword);\n        break;\n      case 'tasklist':\n      case 'task':\n        this.addToken(tokenTypes['ElmtKeyword'], keyword);\n        break;\n      case 'description':\n      case 'date':\n      case 'title':\n      case 'time':\n      case 'from':\n        this.addToken(tokenTypes['AttrKeyword'], keyword);\n        break;\n      default:\n        throw Error(\n          `Lexing Error: '${keyword}' not found in task-shell commands!`\n        );\n    }\n  }\n\n  parseTitleText() {\n    let title = '';\n    // At the beggining, we're skipping the current [ character\n    while (this.next() !== ']') {\n      if (this.i >= this.input.length)\n        throw Error(\n          `Lexing Error: ( '[${title}' ) missing its closing angle bracket: \"`\n        );\n      title += this.c;\n    }\n\n    this.addToken(tokenTypes['TitleText'], title);\n    // We're skipping the ] character because we don't need it\n    this.next();\n  }\n\n  parseDescriptionText() {\n    let description = '';\n\n    // At the beggining, we're skipping the current \" character\n    while (this.next() !== '\"') {\n      if (this.i >= this.input.length)\n        throw Error(\n          `Lexing Error: ( '[${description}' ) missing its closing quote: \"`\n        );\n      description += this.c;\n    }\n\n    this.addToken(tokenTypes['DescriptionText'], description);\n    // We're skipping the \" character because we don't need it\n    this.next();\n  }\n\n  parseNumberOrDate() {\n    // Adding the digit character of the string, so can start building our date or id format\n    let dateOrNumber = this.c;\n\n    // We're also checking for the index i to not be greater than the\n    // input length, so that we don't get a result of undefined if we go\n    // beyond the input string\n    while (!isWhiteSpace(this.next()) && this.i < this.input.length)\n      dateOrNumber += this.c;\n\n    if (isValidDate(dateOrNumber))\n      this.addToken(tokenTypes['DateFormat'], dateOrNumber);\n    else if (isValidNumber(dateOrNumber))\n      this.addToken(tokenTypes['Number'], dateOrNumber);\n    else\n      throw Error(\n        `Lexing Error: '${dateOrNumber}' is not a valid number/date format!`\n      );\n  }\n\n  lex() {\n    while (this.i < this.input.length) {\n      this.c = this.input[this.i];\n\n      if (isWhiteSpace(this.c)) {\n        this.next();\n      } else if (isKeyword(this.c)) {\n        this.parseKeyword();\n      } else if (isLBracket(this.c)) {\n        this.parseTitleText();\n      } else if (isQuote(this.c)) {\n        this.parseDescriptionText();\n      } else if (isDigit(this.c)) {\n        this.parseNumberOrDate();\n      } else {\n        throw Error(\n          `Lexing Error: Unrecongnized token: '${this.c}', please read the Task-Shell Instructions.`\n        );\n      }\n    }\n  }\n}\n\nexport default Lexer;\n","const { tokenTypes } = require('./lexer.js');\n\nclass TaskListParser {\n  constructor(tokens, taskListsObj) {\n    this.tokens = tokens;\n    this.taskListsArray = taskListsObj;\n    this.tokenIdx = 0;\n    // Creating a Deep Copy of the entire taskListsArray\n    this.modTaskListsArray = JSON.parse(JSON.stringify(this.taskListsArray));\n\n    // Start the parsing process\n    this.startParsing();\n  }\n\n  startParsing() {\n    const stmtValue = this.resolve(tokenTypes['StmtKeyword']).value;\n    const elmtValue = this.resolve(tokenTypes['ElmtKeyword']).value;\n\n    switch (stmtValue) {\n      case 'create':\n        if (elmtValue === 'tasklist') this.createTaskList();\n        else this.createTask();\n        break;\n      case 'modify':\n        if (elmtValue === 'tasklist') this.modifyTaskList();\n        else this.modifyTask();\n        break;\n      case 'remove':\n        if (elmtValue === 'tasklist') this.removeTaskList();\n        else this.removeTask();\n        break;\n    }\n  }\n\n  isAnyTokenLeft() {\n    return this.tokenIdx < this.tokens.length;\n  }\n\n  getCurrentToken() {\n    return this.tokens[this.tokenIdx];\n  }\n\n  // Helpers methods to resolve any given value: taskId, taskListId, tokenType, etc...\n  resolveTaskIdOfTaskList(taskListId, taskId) {\n    this.resolveTaskListId(taskListId);\n\n    if (taskId < 0)\n      throw Error(\n        \"Parsing Error: Don't use numbers below of 1 when refering to task-id's!\"\n      );\n\n    if (taskId > this.taskListsArray[taskListId].tasks.length - 1)\n      throw Error(\n        `Parsing Error: There's no task with the task-id of: '${taskId + 1}'!`\n      );\n  }\n\n  resolveTaskListId(taskListId) {\n    if (taskListId < 0)\n      throw Error(\n        \"Parsing Error: Don't use numbers below of 1 when refering to tasklist-id's!\"\n      );\n\n    // (this.taskListsArray.length - 1) because our taskListId has a starting point of 0\n    if (taskListId > this.taskListsArray.length - 1)\n      throw Error(\n        `Parsing Error: There's no tasklist with the tasklist-id of: '${\n          taskListId + 1\n        }'!`\n      );\n  }\n\n  resolve(tokenType) {\n    if (!this.isAnyTokenLeft()) {\n      throw Error(\n        `Parsing Error: A token of type ${tokenType} was expected but we reached the end of the string input.`\n      );\n    }\n\n    if (tokenType !== this.getCurrentToken().type) {\n      throw Error(\n        `Parsing Error: '${\n          this.getCurrentToken().value\n        }' token wasn't expected!`\n      );\n    }\n\n    return this.tokens[this.tokenIdx++];\n  }\n\n  // A helper method to confirm if the value of the current AttrKeyword token is the same as the one we're looking for\n  isCurrentTokenAttrValue(attrValue) {\n    const actualAttrValue = this.resolve(tokenTypes['AttrKeyword']).value;\n\n    if (actualAttrValue !== attrValue)\n      throw Error(\n        `Parsing Error: Expecting '${attrValue}' token, but instead got '${actualAttrValue}' token!`\n      );\n  }\n\n  addTaskList(title = '', description = '', date = '') {\n    this.modTaskListsArray.push({\n      title,\n      description,\n      date,\n      tasks: [],\n    });\n  }\n\n  addTask(taskListId, title = '', description = '', time = '') {\n    this.resolveTaskListId(taskListId);\n\n    this.modTaskListsArray[taskListId].tasks.push({\n      title,\n      description,\n      time,\n    });\n  }\n\n  changeTaskList(taskListId, title, description, date) {\n    this.resolveTaskListId(taskListId);\n\n    if (typeof title !== 'undefined')\n      this.modTaskListsArray[taskListId].title = title;\n    if (typeof description !== 'undefined')\n      this.modTaskListsArray[taskListId].description = description;\n    if (typeof date !== 'undefined')\n      this.modTaskListsArray[taskListId].date = date;\n  }\n\n  changeTask(taskListId, taskId, title, description, time) {\n    this.resolveTaskIdOfTaskList(taskListId, taskId);\n\n    if (typeof title !== 'undefined')\n      this.modTaskListsArray[taskListId].tasks[taskId].title = title;\n    if (typeof description !== 'undefined')\n      this.modTaskListsArray[taskListId].tasks[\n        taskId\n      ].description = description;\n    if (typeof time !== 'undefined')\n      this.modTaskListsArray[taskListId].tasks[taskId].time = time;\n  }\n\n  eraseTaskList(taskListId) {\n    this.resolveTaskListId(taskListId);\n\n    // Deleting the taskList specified\n    this.modTaskListsArray.splice(taskListId, 1);\n  }\n\n  eraseTask(taskListId, taskId) {\n    this.resolveTaskIdOfTaskList(taskListId, taskId);\n\n    // Deleting the task specified from its taskList\n    this.modTaskListsArray[taskListId].tasks.splice(taskId, 1);\n  }\n\n  // Production methods: create tasklist, create task, modify tasklist, modify task, remove tasklist, remove task\n  createTaskList() {\n    const title = this.resolve(tokenTypes['TitleText']).value;\n    let description = '';\n    let date = '';\n\n    if (this.isAnyTokenLeft()) {\n      // If we still have some tokens left in our tokens array\n      let attrValue = this.resolve(tokenTypes['AttrKeyword']).value;\n\n      switch (attrValue) {\n        case 'description':\n          description = this.resolve(tokenTypes['DescriptionText']).value;\n\n          if (this.isAnyTokenLeft()) {\n            this.isCurrentTokenAttrValue('date');\n            date = this.resolve(tokenTypes['DateFormat']).value;\n          }\n          break;\n        case 'date':\n          date = this.resolve(tokenTypes['DateFormat']).value;\n          break;\n        default:\n          throw Error(\n            `Parsing Error: '${attrValue}' attribute not applicable when creating tasklists!`\n          );\n      }\n    }\n\n    // After getting all of the useful values of our tokens, we're checking if there are no tokens left\n    if (!this.isAnyTokenLeft()) {\n      this.addTaskList(title, description, date);\n    } else\n      throw Error(\n        `Parsing Error: Unexpected token at the end of the command: '${this.getCurrentToken()}'!`\n      );\n  }\n\n  createTask() {\n    const title = this.resolve(tokenTypes['TitleText']).value;\n    let taskListId = 0;\n    let description = '';\n    let time = 0;\n\n    let attrValue = this.resolve(tokenTypes['AttrKeyword']).value;\n\n    // Checking for a 'from', 'description', 'time', 'description' attribute keyword\n    switch (attrValue) {\n      case 'from':\n        taskListId =\n          this.resolve(tokenTypes['Number']).value -\n          1; /* -1 because we start our id's at 0, but they are displayed starting at 1 for the users */\n        break;\n\n      case 'description':\n        description = this.resolve(tokenTypes['DescriptionText']).value;\n        attrValue = this.resolve(tokenTypes['AttrKeyword']).value;\n\n        if (attrValue === 'from') {\n          /* OPTION #2: create task [task title] description from tasklist-id */\n          taskListId =\n            this.resolve(tokenTypes['Number']).value -\n            1; /* -1 because we start our id's at 0, but they are displayed starting at 1 for the users */\n        } else if (attrValue === 'time') {\n          /* OPTION #4: create task [task title] description time estimated-time-in-minutes from tasklist-id */\n          time = parseInt(this.resolve(tokenTypes['Number']).value);\n\n          this.isCurrentTokenAttrValue('from');\n          taskListId =\n            this.resolve(tokenTypes['Number']).value -\n            1; /* -1 because we start our id's at 0, but they are displayed starting at 1 for the users */\n        } else\n          throw Error(\n            `Parsing Error: '${attrValue}' id not a valid token. Expecting 'from' or 'time' tokens!`\n          );\n        break;\n\n      case 'time':\n        /* OPTION #3: create task [task title] time estimated-time-in-minutes from tasklist-id */\n        time = parseInt(this.resolve(tokenTypes['Number']).value);\n\n        this.isCurrentTokenAttrValue('from');\n        taskListId =\n          this.resolve(tokenTypes['Number']).value -\n          1; /* -1 because we start our id's at 0, but they are displayed starting at 1 for the users */\n        break;\n\n      default:\n        throw Error(\n          `Parsing Error: '${attrValue}' is not a valid initial token when creating tasks!`\n        );\n    }\n\n    // After getting all of the useful values of our tokens, we're checking if there are no tokens left\n    if (!this.isAnyTokenLeft()) {\n      this.addTask(taskListId, title, description, time);\n    } else\n      throw Error(\n        `Parsing Error: There shouldn't be a token after your your tasklist-id: '${\n          taskListId + 1\n        }' value!`\n      );\n  }\n\n  modifyTaskList() {\n    const taskListId =\n      this.resolve(tokenTypes['Number']).value -\n      1; /* -1 because we start our id's at 0, but they are displayed starting at 1 for the users */\n    let title = undefined;\n    let description = undefined;\n    let date = undefined;\n\n    let attrValue = this.resolve(tokenTypes['AttrKeyword']).value;\n\n    switch (attrValue) {\n      case 'title':\n        title = this.resolve(tokenTypes['TitleText']).value;\n\n        if (this.isAnyTokenLeft()) {\n          this.isCurrentTokenAttrValue('description');\n          description = this.resolve(tokenTypes['DescriptionText']).value;\n          attrValue = this.resolve(tokenTypes['AttrKeyword']).value; // it should be 'date'\n\n          this.isCurrentTokenAttrValue('date');\n          date = this.resolve(tokenTypes['DateFormat']).value;\n        }\n        break;\n\n      case 'description':\n        description = this.resolve(tokenTypes['DescriptionText']).value;\n        break;\n\n      case 'date':\n        date = this.resolve(tokenTypes['DateFormat']).value;\n        break;\n\n      default:\n        throw Error(\n          `Parsing Error: '${attrValue}' is not a valid initial token when modifying tasklists!`\n        );\n    }\n\n    // After getting all of the useful values of our tokens, we're checking if there are no tokens left\n    if (!this.isAnyTokenLeft()) {\n      this.changeTaskList(taskListId, title, description, date);\n    } else\n      throw Error(\n        `Parsing Error: Unexpected token at the end of the command: '${\n          this.getCurrentToken().value\n        }'`\n      );\n  }\n\n  modifyTask() {\n    const taskId =\n      this.resolve(tokenTypes['Number']).value -\n      1; /* -1 because we start our id's at 0, but they are displayed starting at 1 for the users */\n    let taskListId = 0;\n    let title = undefined;\n    let description = undefined;\n    let time = undefined;\n\n    let attrValue = this.resolve(tokenTypes['AttrKeyword']).value;\n\n    switch (attrValue) {\n      case 'title':\n        title = this.resolve(tokenTypes['TitleText']).value;\n\n        attrValue = this.resolve(tokenTypes['AttrKeyword']).value; // it should be 'description'\n\n        if (attrValue === 'from')\n          taskListId = this.resolve(tokenTypes['Number']).value - 1;\n        /* -1 because we start our id's at 0, but they are displayed starting at 1 for the users */ else if (\n          attrValue === 'description'\n        ) {\n          description = this.resolve(tokenTypes['DescriptionText']).value;\n          this.isCurrentTokenAttrValue('time');\n\n          time = parseInt(this.resolve(tokenTypes['Number']).value);\n          this.isCurrentTokenAttrValue('from');\n          taskListId =\n            this.resolve(tokenTypes['Number']).value -\n            1; /* -1 because we start our id's at 0, but they are displayed starting at 1 for the users */\n        } else\n          throw Error(\n            `Parsing Error: Expecting 'from' or 'date' tokens, not '${attrValue}'`\n          );\n\n        break;\n\n      case 'description':\n        description = this.resolve(tokenTypes['DescriptionText']).value;\n\n        this.isCurrentTokenAttrValue('from');\n        taskListId =\n          this.resolve(tokenTypes['Number']).value -\n          1; /* -1 because we start our id's at 0, but they are displayed starting at 1 for the users */\n        break;\n\n      case 'time':\n        time = parseInt(this.resolve(tokenTypes['Number']).value);\n\n        this.isCurrentTokenAttrValue('from');\n        taskListId =\n          this.resolve(tokenTypes['Number']).value -\n          1; /* -1 because we start our id's at 0, but they are displayed starting at 1 for the users */\n        break;\n\n      default:\n        throw Error(\n          `Parsing Error: '${attrValue}' is not a valid initial token when modifying tasks!`\n        );\n    }\n\n    // After getting all of the useful values of our tokens, we're checking if there are no tokens left\n    if (!this.isAnyTokenLeft()) {\n      this.changeTask(taskListId, taskId, title, description, time);\n    } else\n      throw Error(\n        `Parsing Error: Unexpected token: '${this.getCurrentToken().value}'`\n      );\n  }\n\n  removeTaskList() {\n    const currentToken = this.getCurrentToken();\n    let taskListId = 0;\n    let isEraseDescription = false;\n    let isEraseDate = false;\n    let isEraseTaskList = false;\n\n    if (currentToken.type === tokenTypes['Number']) {\n      // Deleting for sure the taskList\n      isEraseTaskList = true;\n      taskListId =\n        this.resolve(tokenTypes['Number']).value -\n        1; /* -1 because we start our id's at 0, but they are displayed starting at 1 for the users */\n    } else if (currentToken.type === tokenTypes['AttrKeyword']) {\n      let attrValue = this.resolve(tokenTypes['AttrKeyword']).value;\n\n      switch (attrValue) {\n        case 'description':\n          isEraseDescription = true;\n\n          /* 'Deleting' only \"description\" */\n          if (currentToken.type === tokenTypes['Number'])\n            taskListId = this.resolve(tokenTypes['Number']) - 1;\n          /* -1 because we start our id's at 0, but they are displayed starting at 1 for the users */ else {\n            /* 'Deleting' both \"description\" and \"date\" */\n            this.isCurrentTokenAttrValue('date');\n\n            taskListId =\n              this.resolve(tokenTypes['Number']).value -\n              1; /* -1 because we start our id's at 0, but they are displayed starting at 1 for the users */\n            isEraseDate = true;\n          }\n          break;\n\n        case 'date':\n          taskListId =\n            this.resolve(tokenTypes['Number']).value -\n            1; /* -1 because we start our id's at 0, but they are displayed starting at 1 for the users */\n          /* 'Deleting' only \"date\" */\n          isEraseDate = true;\n          break;\n\n        default:\n          throw Error(\n            `Only 'description' or 'date' tokens are valid when removing a tasklist attribute!.`\n          );\n      }\n    } else\n      throw Error(\n        `Parsing Error: Unexpected token: '${this.getCurrentToken().value}'`\n      );\n\n    // After getting all of the useful values of our tokens, we're checking if there are no tokens left\n    if (!this.isAnyTokenLeft()) {\n      if (!isEraseTaskList) {\n        // We actually only make some modifications\n        this.changeTaskList(\n          taskListId,\n          undefined,\n          isEraseDescription ? '' : undefined,\n          isEraseDate ? '' : undefined\n        );\n      } else this.eraseTaskList(taskListId);\n    } else\n      throw Error(\n        `Parsing Error: Unexpected token at the end of the statement: '${\n          this.getCurrentToken().value\n        }'`\n      );\n  }\n\n  removeTask() {\n    let taskId = 0;\n    let taskListId = 0;\n    let isEraseTask = false;\n    let isEraseDescription = false;\n    let isEraseTime = false;\n\n    if (this.getCurrentToken().type === tokenTypes['AttrKeyword']) {\n      let attrValue = this.resolve(tokenTypes['AttrKeyword']).value;\n\n      switch (attrValue) {\n        case 'time':\n          isEraseTime = true;\n          break;\n        case 'description':\n          isEraseDescription = true;\n\n          if (this.getCurrentToken().value === 'time') {\n            /* If we're also deleting the task time */\n            isEraseTime = true;\n            this.isCurrentTokenAttrValue('time');\n          }\n          break;\n        default:\n          throw Error(\n            `Only 'description' or 'time' tokens are valid when removing a task attribute!.`\n          );\n      }\n    } else if ((this.getCurrentToken().type = tokenTypes['Number'])) {\n      // Wanting to remove the whole task, and not just the date\n      isEraseTask = true;\n    }\n\n    taskId =\n      this.resolve(tokenTypes['Number']).value -\n      1; /* -1 because we start our id's at 0, but they are displayed starting at 1 for the users */\n    this.isCurrentTokenAttrValue('from');\n    taskListId =\n      this.resolve(tokenTypes['Number']).value -\n      1; /* -1 because we start our id's at 0, but they are displayed starting at 1 for the users */\n\n    // After getting all of the useful values of our tokens, we're checking if there are no tokens left\n    if (!this.isAnyTokenLeft()) {\n      if (isEraseTask) {\n        this.eraseTask(taskListId, taskId);\n      } else {\n        this.changeTask(\n          taskListId,\n          taskId,\n          undefined,\n          isEraseDescription ? '' : undefined,\n          isEraseTime ? '' : undefined\n        );\n      }\n    } else\n      throw Error(\n        `Parsing Error: Unexpected token at the end of the statement: '${\n          this.getCurrentToken().value\n        }'`\n      );\n  }\n\n  getModTaskListsArray() {\n    // Getter method that returns the new Modified TaskListsArray\n    return this.modTaskListsArray;\n  }\n}\n\nexport default TaskListParser;\n","import html2canvas from 'html2canvas';\n\nexport const generateTableImage = async (taskLists, selTaskList) => {\n  // taskTable is the id of our TaskTable container div\n  const canvas = await html2canvas(document.querySelector('#taskListTable'));\n\n  // If the user is using IE/Edge browsers\n  if (window.navigator.msSaveBlob) {\n    window.navigator.msSaveBlob(\n      canvas.msToBlob(),\n      `TASKLIST: ${taskLists[selTaskList].title}.png`\n    );\n  } else {\n    // If the user uses Chrome, FireFox, etc...\n    const a = document.createElement('a');\n\n    document.body.appendChild(a);\n    a.href = canvas.toDataURL();\n    a.download = `TASKLIST: ${taskLists[selTaskList].title}.png`;\n    a.click();\n    document.body.removeChild(a);\n  }\n};\n","const TasklistCommands = {\n  title: 'Tasklist Commands',\n  description:\n    'These are the available commands to be used in task-shell to create, modify and remove tasklists.',\n  date: '02/07/2020',\n  tasks: [\n    // Create Tasklist Commands\n    {\n      title: 'CREATE TASKLIST COMMANDS',\n      description: '',\n      time: 5,\n    },\n    {\n      title: 'Create simple tasklist',\n      description: 'create tasklist [tasklist title]',\n      time: 0,\n    },\n    {\n      title: 'Create tasklist with description',\n      description:\n        'create tasklist [tasklist title] description “some tasklist descr”',\n      time: 0,\n    },\n    {\n      title: 'Create tasklist with date',\n      description: 'create tasklist [tasklist title] date dd/mm/yyyy',\n      time: 0,\n    },\n    {\n      title: 'Create complete tasklist: description and date',\n      description:\n        'create tasklist [tasklist title] description “some tasklist descr” date dd/mm/yyyy',\n      time: 0,\n    },\n    // Modify Tasklists Commands\n    {\n      title: 'MODIFY TASKLIST COMMANDS',\n      description: '',\n      time: 5,\n    },\n    {\n      title: 'Modify tasklist title',\n      description: 'modify tasklist tasklist-id title [new tasklist name]',\n      time: 0,\n    },\n    {\n      title: 'Modify tasklist description',\n      description:\n        'modify tasklist tasklist-id description “new tasklist descr”',\n      time: 0,\n    },\n    {\n      title: 'Modify tasklist date',\n      description: 'modify tasklist tasklist-id date dd/mm/yyyy',\n      time: 0,\n    },\n    {\n      title: 'Modify all tasklist properties: title, description and date',\n      description:\n        'modify tasklist tasklist-id title [new tasklist title] description “new tasklist descr” date dd/mm/yyyy',\n      time: 0,\n    },\n    // Remove Tasklists Commands\n    {\n      title: 'REMOVE TASKLISTS COMMANDS',\n      description: '',\n      time: 5,\n    },\n    {\n      title: 'Remove whole tasklist (warning)',\n      description: 'remove tasklist tasklist-id',\n      time: 0,\n    },\n    {\n      title: 'Remove tasklist description',\n      description: 'remove tasklist description tasklist-id',\n      time: 0,\n    },\n    {\n      title: 'Remove tasklist date',\n      description: 'remove tasklist date tasklist-id',\n      time: 0,\n    },\n    {\n      title: 'Remove tasklist description and date',\n      description: 'remove tasklist description date tasklist-id',\n      time: 0,\n    },\n  ],\n};\n\nexport default TasklistCommands;\n","const TaskCommands = {\n  title: 'Task Commands',\n  description:\n    'These are the available commands to be used in task-shell to create, modify and remove tasks.',\n  date: '02/07/2020',\n  tasks: [\n    // Create Tasks Commands\n    {\n      title: 'CREATE TASK COMMANDS',\n      description: '',\n      time: 5,\n    },\n    {\n      title: 'Create simple task',\n      description: 'create task [task title] from tasklist-id',\n      time: 0,\n    },\n    {\n      title: 'Create task with description',\n      description:\n        'create task [task title] description “task descr.” from tasklist-id',\n      time: 0,\n    },\n    {\n      title: 'Create task with estimated completion time',\n      description:\n        'create task [task title] time estimated-time-minutes from tasklist-id',\n      time: 0,\n    },\n    {\n      title: 'Create complete task: description and estimated time',\n      description:\n        'create task [task title] description “task descr.” time estimated-time-minutes from tasklist-id',\n      time: 0,\n    },\n    // Modify Tasks Commands\n    {\n      title: 'MODIFY TASKLISTS COMMANDS',\n      description: '',\n      time: 5,\n    },\n    {\n      title: 'Modify task title',\n      description:\n        'modify task task-id title [new task title] from tasklist-id',\n      time: 0,\n    },\n    {\n      title: 'Modify task description',\n      description:\n        'modify task task-id description “new task descr.” from tasklist-id',\n      time: 0,\n    },\n    {\n      title: 'Modify task estimated time',\n      description:\n        'modify task task-id time new-estimated-time-minutes from tasklist-id',\n      time: 0,\n    },\n    {\n      title:\n        'Modify all task properties: title, description and estimated time',\n      description:\n        'modify task task-id title [new task title] description “new task descr.” time new-estimated-time-minutes from tasklist-id',\n      time: 0,\n    },\n    // Remove Tasks Commands\n    {\n      title: 'REMOVE TASKS COMMANDS',\n      description: '',\n      time: 5,\n    },\n    {\n      title: 'Remove whole task (warning)',\n      description: 'remove task task-id from tasklist-id',\n      time: 0,\n    },\n    {\n      title: 'Remove task description',\n      description: 'remove task description task-id from tasklist-id',\n      time: 0,\n    },\n    {\n      title: 'Remove task estimated time',\n      description: 'remove task time task-id  from tasklist-id',\n      time: 0,\n    },\n    {\n      title: 'Remove task description and estimated time',\n      description: 'remove task description time task-id from tasklist-id',\n      time: 0,\n    },\n  ],\n};\n\nexport default TaskCommands;\n","import React from 'react';\n\nimport './input-shell.css';\n\nconst InputShell = ({ commandInput, handleCommandInput, handleKeyDown }) => (\n  <input\n    type=\"text\"\n    className=\"input-shell\"\n    value={`$ ${commandInput}`}\n    onChange={handleCommandInput}\n    onKeyDown={handleKeyDown}\n    placeholder=\"Please enter a command...\"\n  />\n);\n\nexport default InputShell;\n","import React from 'react';\n\nimport './select-tasklist-button.css';\n\nconst SelectTasklistButton = ({\n  instructionBtn,\n  taskListId,\n  taskListTitle,\n  isSelected,\n  changeSelection,\n}) => {\n  let btnContainerClass;\n\n  if (instructionBtn) {\n    btnContainerClass = `select-instruction-container ${\n      isSelected ? 'selected-instruction' : ''\n    }`;\n  } else {\n    btnContainerClass = `select-tasklist-container ${\n      isSelected ? 'selected' : ''\n    }`;\n  }\n\n  return (\n    <div\n      className={btnContainerClass}\n      onClick={() => changeSelection(taskListId)}\n    >\n      {/* taskListId + 1 because the user sees the taskListId starging at 1, not 0 */}\n      {instructionBtn ? (\n        <p>{taskListTitle}</p>\n      ) : (\n        <>\n          <span className=\"select-tasklist-button-id\">{taskListId + 1}</span>\n          <span className=\"select-tasklist-button-title\">{taskListTitle}</span>\n        </>\n      )}\n    </div>\n  );\n};\n\nexport default SelectTasklistButton;\n","import React from 'react';\n\nimport './select-tasklists.css';\n\nimport SelectTasklistButton from '../select-tasklist-button/select-tasklist-button';\n\nconst SelectTasklists = ({\n  instructionsList,\n  taskLists,\n  selectedTaskListId,\n  changeSelection,\n}) => {\n  return (\n    <div className=\"page-content--tasklists\">\n      <p className=\"select-tasklist-title\">\n        {instructionsList ? 'COMMANDS INSTRUCTIONS' : 'CREATED TASKLISTS'}\n      </p>\n      {taskLists.map((taskList, id) => (\n        <SelectTasklistButton\n          instructionBtn={instructionsList}\n          key={id}\n          taskListId={id}\n          taskListTitle={taskList.title}\n          isSelected={id === selectedTaskListId}\n          changeSelection={changeSelection}\n        />\n      ))}\n    </div>\n  );\n};\n\nexport default SelectTasklists;\n","import React from 'react';\n\nimport './tasklist-header.css';\n\nconst TaskListHeader = ({ title, date }) => {\n  return (\n    <div className='tasklist-container-title'>\n      <h1 className='tasklist-title'>{title}</h1>\n      {date && <p className='tasklist-date'>{date}</p>}\n    </div>\n  );\n};\n\nexport default TaskListHeader;\n","import React from 'react';\n\nimport './tasklist-description.css';\n\nconst TaskListDescription = ({ description }) => {\n  return (\n    description && (\n      <div className=\"tasklist-container-description\">\n        <p className=\"tasklist-description\">{description}</p>\n      </div>\n    )\n  );\n};\n\nexport default TaskListDescription;\n","import React from 'react';\n\nimport './tasklist-task-row.css';\n\nconst TaskListTaskRow = ({ title, description, time, taskId }) => {\n  return (\n    <div className=\"tasklist-task-row-container\">\n      <div className=\"title-container-task\">\n        <p className=\"task-id\">{taskId}</p>\n        <h1 className=\"task-title\">{title}</h1>\n      </div>\n      {description && <p className=\"task-description\">{description}</p>}\n      {time > 0 && (\n        <div className=\"task-time\">{`ESTIMATED TIME: ${time} MINUTES`}</div>\n      )}\n    </div>\n  );\n};\n\nexport default TaskListTaskRow;\n","import React from 'react';\n\nimport TaskListTaskRow from '../tasklist-task-row/tasklist-task-row';\n\nconst TaskListTasks = ({ taskList }) => (\n  <>\n    {taskList.tasks.map(({ ...taskProps }, id) => {\n      return <TaskListTaskRow key={id} {...taskProps} taskId={id + 1} />;\n    })}\n  </>\n);\n\nexport default TaskListTasks;\n","import React, { PureComponent } from 'react';\n\nimport './tasklist-table.css';\nimport TaskListHeader from '../tasklist-header/tasklist-header';\nimport TaskListDescription from '../tasklist-description/tasklist-description';\nimport TaskListTasks from '../tasklist-tasks/tasklist-tasks';\n\n// We used PureComponent to avoid unnecesary re-renders when the task-shell input changes\nclass TaskListTable extends PureComponent {\n  render() {\n    const { taskList } = this.props;\n    return (\n      <div id=\"taskListTable\" className=\"table-container\">\n        <TaskListHeader title={taskList.title} date={taskList.date} />\n        <TaskListDescription description={taskList.description} />\n        <p className=\"tasklist-table-title\">TASKS</p>\n        {taskList.tasks.length ? (\n          <TaskListTasks taskList={taskList} />\n        ) : (\n          <p className=\"tasklist-table-no-tasks\">\n            Empty task list, please create some tasks.\n          </p>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default TaskListTable;\n","import React from 'react';\n\nimport './save-image-button.css';\n\nconst SaveImageButton = ({ children, onClick }) => (\n  <button className='save-image-button' onClick={onClick}>\n    {children}\n  </button>\n);\n\nexport default SaveImageButton;\n","import React, { Component } from 'react';\n\nimport { runProvidedCommand, updateSelTasklist } from './utils/index';\nimport { generateTableImage } from './App.utils';\nimport { backupTaskLists, backupInputCommands } from './utils/storage-backup';\n\n// Instruction commands in order to use task-shell\nimport TasklistCommands from './data/tasklist-commands';\nimport TaskCommands from './data/task-commands';\n\nimport './App.css';\nimport InputShell from './components/input-shell/input-shell';\nimport SelectTaskLists from './components/select-tasklists/select-tasklists';\nimport TaskListTable from './components/tasklist-table/tasklist-table';\nimport SaveImageButton from './components/save-image-button/save-image-button';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isLoading: true, // A flag to display only our content when it's false\n      commandInput: '',\n      commandError: '',\n      taskLists: [],\n      selTaskList: -1, // Meaning that there's no tasklist within our taskLists array\n      inputCommandsArr: [],\n      cachedInputsIdx: -1, // This id helps us to move between the different commands we have in cache\n      maxCachedInputs: 5, // We're only storing up to 5 commands in our cache\n      instructionsArr: [TasklistCommands, TaskCommands],\n      currentTasklist: TasklistCommands, // The tasklist object to display in screen\n      selInstrList: 0,\n    };\n  }\n\n  componentDidMount() {\n    const taskListsBackup = localStorage.getItem('taskLists');\n    const commandsHistoryBackup = localStorage.getItem('commandsHistory');\n\n    // Default state values\n    let selTaskList = -1;\n    let taskLists = [];\n    let inputCommandsArr = [];\n    let currentTasklist;\n    let selInstrList;\n\n    if (taskListsBackup) {\n      const taskListsObj = JSON.parse(taskListsBackup);\n      selTaskList = taskListsObj.selTaskList;\n      taskLists = taskListsObj.taskLists;\n\n      currentTasklist = taskLists[selTaskList];\n      selInstrList = -1; // Since we found created tasklists in storage, we don't need to show instructions\n    } else {\n      currentTasklist = this.state.currentTasklist;\n      selInstrList = 0;\n    }\n\n    if (commandsHistoryBackup) {\n      inputCommandsArr = JSON.parse(commandsHistoryBackup);\n    }\n\n    this.setState({\n      isLoading: false,\n      inputCommandsArr,\n      taskLists,\n      selTaskList,\n      selInstrList,\n      currentTasklist,\n    });\n  }\n\n  tasklistsBackup = () => {\n    const { taskLists, selTaskList } = this.state;\n    localStorage.setItem(\n      'taskLists',\n      JSON.stringify({ taskLists, selTaskList })\n    );\n  };\n\n  handleCommandInput = event => {\n    const { value } = event.target;\n\n    // We're skipping the first 2 string characters because that's our inputs prefix\n    this.setState({ commandInput: value.substring(2) });\n  };\n\n  handleChangeTasklist = selectedIndex => {\n    const { taskLists } = this.state;\n\n    const currentTasklist = taskLists[selectedIndex];\n\n    this.setState(\n      { selTaskList: selectedIndex, currentTasklist, selInstrList: -1 },\n      () => backupTaskLists(taskLists, selectedIndex)\n    );\n  };\n\n  handleChangeInstructionList = selectedIndex => {\n    const { instructionsArr } = this.state;\n\n    const currentTasklist = instructionsArr[selectedIndex];\n\n    this.setState({\n      selTaskList: -1,\n      selInstrList: selectedIndex,\n      currentTasklist,\n    });\n  };\n\n  runExecutionCommand = () => {\n    this.setState(\n      prevState => {\n        // Running the provided command\n        const { error, taskLists } = runProvidedCommand(\n          prevState.taskLists,\n          prevState.commandInput\n        );\n\n        // If we don't have an error: our command was successful\n        if (!error) {\n          // Updating the selected Task List index\n          const newSelTaskList = updateSelTasklist(\n            taskLists.length,\n            prevState.taskLists.length,\n            prevState.selTaskList\n          );\n\n          let currentTasklist;\n          let selInstrList;\n\n          // If the last tasklist was deleted\n          if (newSelTaskList < 0) {\n            currentTasklist = prevState.instructionsArr[0];\n            selInstrList = 0;\n          } else {\n            // Updating the new selected tasklist\n            currentTasklist = taskLists[newSelTaskList];\n            selInstrList = -1;\n          }\n\n          // Storing the command in our inputCommandsArray\n          if (prevState.inputCommandsArr.length < prevState.maxCachedInputs) {\n            this.state.inputCommandsArr.push(prevState.commandInput);\n          } else {\n            // If we reach the limit of our inputCommandsArray\n            this.state.inputCommandsArr.shift(); // Deleting the first cached command\n            this.state.inputCommandsArr.push(prevState.commandInput);\n          }\n\n          // Backing up our history of commands\n          backupInputCommands(prevState.inputCommandsArr);\n\n          return {\n            commandInput: '',\n            commandError: error,\n            selTaskList: newSelTaskList,\n            cachedInputsIdx: -1, // Restarting our index for moving through the cached commands\n            selInstrList,\n            taskLists,\n            currentTasklist,\n          };\n        }\n\n        // If we have an error, we keep the command intact, to give the user a chance to correct the typo\n        return {\n          commandInput: prevState.commandInput,\n          commandError: error,\n        };\n      },\n      () => {\n        this.tasklistsBackup();\n      }\n    );\n  };\n\n  handleKeyDown = event => {\n    // eslint-disable-next-line default-case\n    switch (event.keyCode) {\n      case 13: // Enter pressed\n        this.runExecutionCommand();\n        break;\n\n      case 38: // Up key pressed\n        this.setState(prevState => {\n          const commandsArrLen = prevState.inputCommandsArr.length;\n\n          // If we don't have any command stored\n          if (!commandsArrLen) {\n            return {\n              commandInput: '',\n            };\n          }\n          // If it's our first time moving through the cached commands\n          else if (prevState.cachedInputsIdx === -1 && commandsArrLen) {\n            return {\n              commandInput: prevState.inputCommandsArr[commandsArrLen - 1],\n              cachedInputsIdx: commandsArrLen - 1,\n            };\n          } else if (prevState.cachedInputsIdx === 0) {\n            // If we got to the top of the oldest command\n            return {\n              commandInput: prevState.inputCommandsArr[0],\n            };\n          } else {\n            return {\n              commandInput:\n                prevState.inputCommandsArr[prevState.cachedInputsIdx - 1],\n              cachedInputsIdx: prevState.cachedInputsIdx - 1,\n            };\n          }\n        });\n        break;\n\n      case 40: // Down key pressed\n        this.setState(prevState => {\n          const commandsArrLen = prevState.inputCommandsArr.length;\n\n          if (prevState.cachedInputsIdx === -1) {\n            return {\n              commandInput: '',\n            };\n          } else if (prevState.cachedInputsIdx === commandsArrLen - 1) {\n            // If we got to the top of the newest command\n            return {\n              commandInput:\n                prevState.inputCommandsArr[prevState.cachedInputsIdx],\n              cachedInputsIdx: -1,\n            };\n          } else {\n            return {\n              commandInput:\n                prevState.inputCommandsArr[prevState.cachedInputsIdx],\n              cachedInputsIdx: prevState.cachedInputsIdx + 1,\n            };\n          }\n        });\n\n        break;\n    }\n  };\n\n  render() {\n    const {\n      commandInput,\n      commandError,\n      instructionsArr,\n      taskLists,\n      selTaskList,\n      isLoading,\n      currentTasklist,\n      selInstrList,\n    } = this.state;\n\n    return (\n      <div className=\"page-container\">\n        {!isLoading && (\n          <>\n            <h1 className=\"page-title\">TASK-SHELL</h1>\n            <InputShell\n              commandInput={commandInput}\n              handleCommandInput={this.handleCommandInput}\n              handleKeyDown={this.handleKeyDown}\n            />\n            {commandError && <p className=\"error-message\">{commandError}</p>}\n            <div className=\"page-content\">\n              <div className=\"page-content--select-panel\">\n                {\n                  /* Created Tasklists */\n                  taskLists.length ? (\n                    <SelectTaskLists\n                      taskLists={taskLists}\n                      selectedTaskListId={selTaskList}\n                      changeSelection={this.handleChangeTasklist}\n                    />\n                  ) : null\n                }\n\n                {/* Instructions Commands Tasklists*/}\n                <SelectTaskLists\n                  instructionsList\n                  taskLists={instructionsArr}\n                  selectedTaskListId={selInstrList}\n                  changeSelection={this.handleChangeInstructionList}\n                />\n              </div>\n\n              <div className=\"page-content--table\">\n                <TaskListTable taskList={currentTasklist} />\n\n                {\n                  /* if none of the command lists are selected */\n                  selInstrList < 0 ? (\n                    <SaveImageButton\n                      onClick={() => {\n                        generateTableImage(taskLists, selTaskList);\n                      }}\n                    >\n                      Save tasklist as Image\n                    </SaveImageButton>\n                  ) : null\n                }\n              </div>\n            </div>\n          </>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default React.memo(App);\n","export const backupTaskLists = (taskLists, selTaskList) => {\n  localStorage.setItem('taskLists', JSON.stringify({ taskLists, selTaskList }));\n};\n\nexport const backupInputCommands = inputCommandsArr => {\n  localStorage.setItem('commandsHistory', JSON.stringify(inputCommandsArr));\n};\n","import Lexer from './lexer';\nimport TaskListParser from './parser';\n\nexport const runProvidedCommand = (taskListsArray, input) => {\n  try {\n    const lexer = new Lexer(input);\n    const parser = new TaskListParser(lexer.tokens, taskListsArray);\n    return { taskLists: parser.getModTaskListsArray(), error: undefined };\n  } catch (error) {\n    return {\n      taskLists: taskListsArray,\n      error: error.message,\n    };\n  }\n};\n\n// This functions helps us to update the current selected tasklist to be displayed on screen\nexport const updateSelTasklist = (\n  taskListsLength,\n  prevTaskListsLength,\n  prevSelTaskList\n) => {\n  // If a tasklist was only modified\n  if (prevTaskListsLength === taskListsLength) return prevSelTaskList;\n\n  // If a new tasklist was created\n  if (prevTaskListsLength < taskListsLength) return taskListsLength - 1;\n\n  // If a tasklist was removed\n  if (taskListsLength < prevTaskListsLength) {\n    // If tasklist array is empty\n    if (!taskListsLength) return -1;\n\n    // If the prev selected tasklist respects the new length of the array\n    if (prevSelTaskList < taskListsLength - 1) return prevSelTaskList;\n\n    // If the prev selected tasklist was the end item\n    return taskListsLength - 1;\n  }\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nimport './index.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}